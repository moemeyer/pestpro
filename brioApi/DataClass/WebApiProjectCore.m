//
// WebApiProjectCore.m
// Project 1.0
//
// Generated by ApiGenerator on Tuesday, November 21, 2023
//

#import "WebApiProjectCore.h"
#import "WebApiProjectData.h"
#import <Cocoa/Cocoa.h>

@implementation WebApiProjectManagerCore

@synthesize delegate;
@dynamic baseURL;
@synthesize timeout;

-(void)setBaseURL:(NSString *)value
{
	if([value hasSuffix:@"/"] == YES)
		_baseURL = [value substringToIndex:value.length - 1];
	else _baseURL = value;
}

-(NSString*)baseURL
{
	return _baseURL;
}

-(NSData*)startReqest:(NSMutableURLRequest*)request withResponse:(NSHTTPURLResponse**)response withError:(NSError**)error
{
	@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@"You must override %@ in a subclass", NSStringFromSelector(_cmd)] userInfo:nil];
}

-(void)removeCookies
{
	NSHTTPCookieStorage* cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage];
	NSArray* facebookCookies = [cookies cookiesForURL:[NSURL URLWithString:self.baseURL]];
	for (NSHTTPCookie* cookie in facebookCookies)
		[cookies deleteCookie:cookie];
}

-(instancetype)init
{
	self = [super init];
	if(self){
		self.baseURL = @"https://pestproridall.briostack.com/api";
		self.timeout = 30;
	}
	return self;
}

@end

@implementation WebApiProjectApiBase

@synthesize manager;

-(instancetype)initWithManager:(WebApiProjectManagerCore*)apiManager
{
	self = [super init];
	if(self){
		self.manager = apiManager;
	}
	return self;
}

-(instancetype)init
{
	@throw [NSException exceptionWithName:@"method not allowed" reason:@"method init not allowed, use initWithManager:" userInfo:nil];
	return nil;
}

@end

NSString* WebApiProjectObjectToJson(id object)
{
	NSError *error = nil;
	NSData *data = [NSJSONSerialization dataWithJSONObject:object options:0 error:&error];
	if(error != nil)
		@throw [NSException exceptionWithName:error.domain reason:error.description userInfo:error.userInfo];

	return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
}

NSDictionary* WebApiProjectPostToDictionary(NSString *value)
{
#if __IPHONE_8_0 || __MAC_10_10
	NSMutableDictionary *result = [NSMutableDictionary dictionary];
	NSURLComponents *components = [[NSURLComponents alloc] init];
	components.query = value;
	for (int i=0; i<components.queryItems.count; i++) {
		NSURLQueryItem *it = components.queryItems[i];
		[result setObject:it.value forKey:it.name];
	}
	return result;
#else
	return nil;
#endif
}

NSString* WebApiProjectDictionaryToPost(NSDictionary *value, NSString *name)
{
	NSMutableString *result = [NSMutableString string];
	for (NSString *key in value.allKeys) {
		NSString *key2 = [key stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet alphanumericCharacterSet]];
		NSObject *val = value[key];
		NSString *toInsert = nil;

		if([val isKindOfClass:[NSString class]] == YES)
			toInsert = [(NSString*)val stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet alphanumericCharacterSet]];
		if([val isKindOfClass:[NSNumber class]] == YES)
			toInsert = [(NSNumber*)val stringValue];
		if([val isKindOfClass:[WebApiProjectData class]] == YES){
			NSString *res = WebApiProjectDictionaryToPost([(WebApiProjectData*)val save], [NSString stringWithFormat:@"%@[%@]", name, key2]);
			if(result.length > 0)
				[result appendString:@"&"];
			[result appendString:res];
		}
		if([val isKindOfClass:[NSDictionary class]] == YES){
			NSString *res = WebApiProjectDictionaryToPost((NSDictionary*)val, [NSString stringWithFormat:@"%@[%@]", name, key2]);
			if(result.length > 0)
				[result appendString:@"&"];
			[result appendString:res];
		}
		if([val isKindOfClass:[NSArray class]] == YES){
			NSString *res = WebApiProjectArrayToPost((NSArray*)val, [NSString stringWithFormat:@"%@[%@]", name, key2]);
			if(result.length > 0)
				[result appendString:@"&"];
			[result appendString:res];
		}

		if(toInsert != nil){
			if(result.length > 0)
				[result appendString:@"&"];
			[result appendFormat:@"%@[%@]=%@", name, key, toInsert];
			}
		}
	return result;
}

NSString* WebApiProjectArrayToPost(NSArray *value, NSString *name)
{
	NSMutableString *result = [NSMutableString string];
	for (int i=0; i<value.count; i++) {
		NSObject *val = value[i];
		NSString *toInsert = nil;

		if([val isKindOfClass:[NSString class]] == YES)
			toInsert = [(NSString*)val stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet alphanumericCharacterSet]];
		if([val isKindOfClass:[NSNumber class]] == YES)
			toInsert = [(NSNumber*)val stringValue];
		if([val isKindOfClass:[WebApiProjectData class]] == YES){
			NSString *res = WebApiProjectDictionaryToPost([(WebApiProjectData*)val save], [NSString stringWithFormat:@"%@[%d]", name, i]);
			if(result.length > 0)
				[result appendString:@"&"];
			[result appendString:res];
		}
		if([val isKindOfClass:[NSDictionary class]] == YES){
			NSString *res = WebApiProjectDictionaryToPost((NSDictionary*)val, [NSString stringWithFormat:@"%@[%d]", name, i]);
			if(result.length > 0)
				[result appendString:@"&"];
			[result appendString:res];
		}
		if([val isKindOfClass:[NSArray class]] == YES){
			NSString *res = WebApiProjectArrayToPost((NSArray*)val, [NSString stringWithFormat:@"%@[%d]", name, i]);
			if(result.length > 0)
				[result appendString:@"&"];
			[result appendString:res];
		}

		if(toInsert != nil){
			if(result.length > 0)
				[result appendString:@"&"];
			[result appendFormat:@"%@[%d]=%@", name, i, toInsert];
			}
		}
	return result;
}

NSString* WebApiProjectObjectToPost(NSObject *value, NSString *name)
{
	if([value isKindOfClass:[NSArray class]] == YES)
		return WebApiProjectArrayToPost((NSArray*)value, name);
	if([value isKindOfClass:[NSDictionary class]] == YES)
		return WebApiProjectDictionaryToPost((NSDictionary*)value, name);
	if([value isKindOfClass:[WebApiProjectData class]] == YES)
		return WebApiProjectDictionaryToPost([(WebApiProjectData*)value save], name);
	return @"";
}

void WebApiProjectDictionaryToPostDataValue(NSObject *value, NSString *name, NSMutableData *content)
{
	if(([value isKindOfClass:[NSData class]] == YES) || ([value isKindOfClass:[NSImage class]] == YES)){
		[content appendData:[[NSString stringWithFormat:@"Content-Disposition: form-data; name=\"%@\"; filename=\"file\"\r\n", name] dataUsingEncoding:NSUTF8StringEncoding]];
		[content appendData:[@"Content-Type: application/octet-stream\r\n\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
		if([value isKindOfClass:[NSData class]] == YES)
			[content appendData:(NSData*)value];
	}else{
		[content appendData:[[NSString stringWithFormat:@"Content-Disposition: form-data; name=\"%@\"\r\n\r\n", name] dataUsingEncoding:NSUTF8StringEncoding]];
		[content appendData:[[NSString stringWithFormat:@"%@", value] dataUsingEncoding:NSUTF8StringEncoding]];
	}
	[content appendData:[@"\r\n--0xKhTmLbOuNdArY\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
}

void WebApiProjectDictionaryToPostData(NSDictionary *value, NSString *name, NSMutableData *content)
{
	for (NSString *key in value.allKeys) {
		NSString *key2 = [key stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet alphanumericCharacterSet]];
		NSObject *val = value[key];

		if(([val isKindOfClass:[NSString class]] == YES)
			|| ([val isKindOfClass:[NSNumber class]] == YES)
			|| ([val isKindOfClass:[NSData class]] == YES)
			|| ([val isKindOfClass:[NSImage class]] == YES))
			WebApiProjectDictionaryToPostDataValue(val, [NSString stringWithFormat:@"%@[%@]", name, key], content);
		else
		if([val isKindOfClass:[WebApiProjectData class]] == YES)
			WebApiProjectDictionaryToPostData([(WebApiProjectData*)val save], [NSString stringWithFormat:@"%@[%@]", name, key2], content);
		else
		if([val isKindOfClass:[NSDictionary class]] == YES)
			WebApiProjectDictionaryToPostData((NSDictionary*)val, [NSString stringWithFormat:@"%@[%@]", name, key2], content);
		else
		if([val isKindOfClass:[NSArray class]] == YES)
			WebApiProjectArrayToPostData((NSArray*)val, [NSString stringWithFormat:@"%@[%@]", name, key2], content);
	}
}

void WebApiProjectArrayToPostData(NSArray *value, NSString *name, NSMutableData *content)
{
	for (int i=0; i<value.count; i++) {
		NSObject *val = value[i];

		if(([val isKindOfClass:[NSString class]] == YES)
			|| ([val isKindOfClass:[NSNumber class]] == YES)
			|| ([val isKindOfClass:[NSData class]] == YES)
			|| ([val isKindOfClass:[NSImage class]] == YES))
			WebApiProjectDictionaryToPostDataValue(val, [NSString stringWithFormat:@"%@[%d]", name, i], content);
		else
		if([val isKindOfClass:[WebApiProjectData class]] == YES)
			WebApiProjectDictionaryToPostData([(WebApiProjectData*)val save], [NSString stringWithFormat:@"%@[%d]", name, i], content);
		else
		if([val isKindOfClass:[NSDictionary class]] == YES)
			WebApiProjectDictionaryToPostData((NSDictionary*)val, [NSString stringWithFormat:@"%@[%d]", name, i], content);
		else
		if([val isKindOfClass:[NSArray class]] == YES)
			WebApiProjectArrayToPostData((NSArray*)val, [NSString stringWithFormat:@"%@[%d]", name, i], content);
	}
}

void WebApiProjectObjectToPostData(NSObject *value, NSString *name, NSMutableData *content)
{
	if([value isKindOfClass:[NSArray class]] == YES)
		WebApiProjectArrayToPostData((NSArray*)value, name, content);
	else if([value isKindOfClass:[NSDictionary class]] == YES)
		WebApiProjectDictionaryToPostData((NSDictionary*)value, name, content);
	else if([value isKindOfClass:[WebApiProjectData class]] == YES)
		WebApiProjectDictionaryToPostData([(WebApiProjectData*)value save], name, content);
}


extern NSString* WebApiProjectbase64EncodeData(NSData *objData)
{
	static const char _base64EncodingTable[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	const unsigned char * objRawData = [objData bytes];
	char * objPointer;
	char * strResult;

	// Get the Raw Data length and ensure we actually have data
	long intLength = [objData length];
	if (intLength == 0) return nil;

	// Setup the String-based Result placeholder and pointer within that placeholder
	strResult = (char *)malloc(((intLength + 2) / 3) * 4 + 1);
	objPointer = strResult;

	// Iterate through everything
	while (intLength > 2) { // keep going until we have less than 24 bits
		*objPointer++ = _base64EncodingTable[objRawData[0] >> 2];
		*objPointer++ = _base64EncodingTable[((objRawData[0] & 0x03) << 4) + (objRawData[1] >> 4)];
		*objPointer++ = _base64EncodingTable[((objRawData[1] & 0x0f) << 2) + (objRawData[2] >> 6)];
		*objPointer++ = _base64EncodingTable[objRawData[2] & 0x3f];

		// we just handled 3 octets (24 bits) of data
		objRawData += 3;
		intLength -= 3;
	}

	// now deal with the tail end of things
	if (intLength != 0) {
		*objPointer++ = _base64EncodingTable[objRawData[0] >> 2];
		if (intLength > 1) {
			*objPointer++ = _base64EncodingTable[((objRawData[0] & 0x03) << 4) + (objRawData[1] >> 4)];
			*objPointer++ = _base64EncodingTable[(objRawData[1] & 0x0f) << 2];
			*objPointer++ = '=';
		} else {
			*objPointer++ = _base64EncodingTable[(objRawData[0] & 0x03) << 4];
			*objPointer++ = '=';
			*objPointer++ = '=';
		}
	}

	// Terminate the string-based result
	*objPointer = '\0';

	// Return the results as an NSString object
	return [NSString stringWithCString:strResult encoding:NSASCIIStringEncoding];
}

extern NSData* WebApiProjectbase64DecodeString(NSString *strBase64)
{
	if(strBase64 == nil)
		return nil;
	static const short _base64DecodingTable[256] = {
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -2, -1, -1, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
		-1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62, -2, -2, -2, 63,
		52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -2, -2, -2,
		-2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, -2,
		-2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
		41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
		-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2
	};

	const char * objPointer = [strBase64 cStringUsingEncoding:NSASCIIStringEncoding];
	long intLength = strlen(objPointer);
	int intCurrent;
	int i = 0, j = 0, k;

	unsigned char * objResult;
	objResult = malloc(intLength);

	// Run through the whole string, converting as we go
	while ( ((intCurrent = *objPointer++) != '\0') && (intLength-- > 0) ) {
		if (intCurrent == '=') {
			if (*objPointer != '=' && ((i % 4) == 1)) {// || (intLength > 0)) {
				// the padding character is invalid at this point -- so this entire string is invalid
				free(objResult);
				return nil;
			}
			continue;
		}

		intCurrent = _base64DecodingTable[intCurrent];
		if (intCurrent == -1) {
			// we're at a whitespace -- simply skip over
			continue;
		} else if (intCurrent == -2) {
			// we're at an invalid character
			free(objResult);
			return nil;
		}

		switch (i % 4) {
			case 0:
				objResult[j] = intCurrent << 2;
				break;

			case 1:
				objResult[j++] |= intCurrent >> 4;
				objResult[j] = (intCurrent & 0x0f) << 4;
				break;

			case 2:
				objResult[j++] |= intCurrent >>2;
				objResult[j] = (intCurrent & 0x03) << 6;
				break;

			case 3:
				objResult[j++] |= intCurrent;
				break;
		}
		i++;
	}

	// mop things up if we ended on a boundary
	k = j;
	if (intCurrent == '=') {
		switch (i % 4) {
			case 1:
				// Invalid state
				free(objResult);
				return nil;

			case 2:
				k++;
				// flow through
			case 3:
				objResult[k] = 0;
		}
	}

	// Cleanup and setup the return NSData
	NSData * objData = [[NSData alloc] initWithBytes:objResult length:j];
	free(objResult);
	return objData;
}

extern NSString* WebApiProjectbase64EncodeString(NSString *strData)
{
	return WebApiProjectbase64EncodeData([strData dataUsingEncoding: NSUTF8StringEncoding]);
}
